# Enhanced Go Logger Package

A comprehensive, production-ready logging package for Go applications with structured logging, multiple output formats, and specialized domain logging capabilities.

## üìã Table of Contents

- [Features](#-features)
- [Architecture](#-architecture)
- [Quick Start](#-quick-start)
- [Configuration](#-configuration)
- [Basic Usage](#-basic-usage)
- [Enhanced Logging Methods](#-enhanced-logging-methods)
- [Specialized Logging](#-specialized-logging)
- [Output Formats](#-output-formats)
- [Component Loggers](#-component-loggers)
- [Best Practices](#-best-practices)
- [Examples](#-examples)
- [Environment Configuration](#-environment-configuration)

## üöÄ Features

### Core Features
- **Structured Logging**: JSON, Pretty, and Text formats
- **Multiple Log Levels**: Debug, Info, Warning, Error, Fatal
- **Thread-Safe**: Concurrent logging support with mutex protection
- **Context-Aware**: Rich contextual information with each log entry
- **Environment-Based Configuration**: Different settings per environment

### Advanced Features
- **Layer-Based Organization**: Handler, Service, Repository, etc.
- **Enhanced Error Tracking**: Automatic error categorization and cause detection
- **Performance Monitoring**: Built-in performance logging and categorization
- **Security Event Logging**: Specialized security event tracking
- **Email Masking**: Automatic PII protection
- **Caller Information**: File, function, and line number tracking

### Specialized Loggers
- Authentication attempts
- API requests with performance metrics
- Database operations
- Service calls
- Validation errors
- User activities
- Security events
- Performance metrics

## üèó Architecture

The package is organized into focused modules:

```
logger/
‚îú‚îÄ‚îÄ logger_type.go          # Core types and constants
‚îú‚îÄ‚îÄ logger_core.go          # Main logger implementation
‚îú‚îÄ‚îÄ logger_formatters.go    # Output formatting
‚îú‚îÄ‚îÄ logger_specialized.go   # Domain-specific logging
‚îú‚îÄ‚îÄ logger_utils.go         # Helper utilities
‚îú‚îÄ‚îÄ logger_factory.go       # Component logger constructors
‚îî‚îÄ‚îÄ logger_global.go        # Global interface and convenience functions
```

## ‚ö° Quick Start

### Basic Setup

```go
package main

import (
    "your-project/logger"
)

func main() {
    // Use global logger (simplest approach)
    logger.Info("Application starting")
    
    // Or create your own logger instance
    log := logger.NewLogger()
    log.Info("Custom logger instance")
}
```

### With Context

```go
logger.Info("User login", map[string]interface{}{
    "user_id": "123",
    "email": "user@example.com",
    "ip": "192.168.1.1",
})
```

## ‚öôÔ∏è Configuration

### Environment Variables

```bash
# Set log format (json, text, pretty)
export LOG_FORMAT=pretty

# Set environment (affects default log level and format)
export APP_ENV=development
# or
export ENVIRONMENT=production
```

### Programmatic Configuration

```go
// Set output format
logger.SetOutputFormat(logger.FormatPretty)

// Enable/disable debug logging
logger.SetDebugLogging(true)

// Set minimum log level
logger.SetMinLevel(logger.InfoLevel)

// Set global context
logger.AddGlobalField("service", "user-service")
logger.AddGlobalField("version", "1.2.3")
```

## üìù Basic Usage

### Standard Log Levels

```go
// Debug - detailed information for debugging
logger.Debug("Processing user data", map[string]interface{}{
    "user_id": "123",
    "step": "validation",
})

// Info - general information
logger.Info("User successfully created", map[string]interface{}{
    "user_id": "123",
    "email": "user@example.com",
})

// Warning - something unexpected but not critical
logger.Warning("Rate limit approaching", map[string]interface{}{
    "user_id": "123",
    "current_rate": 95,
    "limit": 100,
})

// Error - error conditions
logger.Error("Failed to save user", map[string]interface{}{
    "user_id": "123",
    "error": err.Error(),
})

// Fatal - critical errors that cause program exit
logger.Fatal("Database connection failed", map[string]interface{}{
    "error": err.Error(),
})
```

## üéØ Enhanced Logging Methods

### Error with Detailed Cause Tracking

```go
// Error with detailed cause tracking
logger.ErrorWithCause(
    "Payment processing failed",
    "payment_gateway_timeout",
    logger.LayerService,
    "process_payment",
    map[string]interface{}{
        "payment_id": "pay_123",
        "amount": 99.99,
    },
)

// Warning with cause
logger.WarningWithCause(
    "Slow database query detected",
    "performance_degradation",
    logger.LayerRepository,
    "find_user",
    map[string]interface{}{
        "query_time": 2500,
        "table": "users",
    },
)

// Info with operation context
logger.InfoWithOperation(
    "Cache hit successful",
    logger.LayerCache,
    "get_user_profile",
    map[string]interface{}{
        "user_id": "123",
        "cache_key": "user_profile_123",
    },
)
```

## üîß Specialized Logging

### Authentication Logging

```go
// Successful authentication
logger.LogAuthAttempt("user@example.com", true, "valid_credentials", map[string]interface{}{
    "ip": "192.168.1.1",
    "user_agent": "Mozilla/5.0...",
})

// Failed authentication
logger.LogAuthAttempt("user@example.com", false, "invalid_password", map[string]interface{}{
    "ip": "192.168.1.1",
    "attempts": 3,
})
```

### API Request Logging

```go
import "time"

duration := time.Since(startTime)
logger.LogAPIRequest("POST", "/api/users", 201, duration, map[string]interface{}{
    "user_id": "123",
    "ip": "192.168.1.1",
})
```

### Database Operations

```go
// Successful operation
logger.LogDBOperation("INSERT", "users", true, nil, map[string]interface{}{
    "user_id": "123",
    "affected_rows": 1,
})

// Failed operation
logger.LogDBOperation("UPDATE", "users", false, err, map[string]interface{}{
    "user_id": "123",
    "query": "UPDATE users SET...",
})
```

### Service Calls

```go
// External service call
logger.LogServiceCall("payment-service", "ProcessPayment", true, nil, map[string]interface{}{
    "payment_id": "pay_123",
    "amount": 99.99,
})

// Failed service call
logger.LogServiceCall("email-service", "SendEmail", false, err, map[string]interface{}{
    "email": "user@example.com",
    "template": "welcome",
})
```

### Validation Errors

```go
logger.LogValidationError("email", "Invalid email format", "invalid-email")
logger.LogValidationError("password", "Password too short", "123") // Will be masked automatically
```

### User Activity Logging

```go
logger.LogUserActivity("123", "user@example.com", "create", "order", map[string]interface{}{
    "order_id": "ord_456",
    "amount": 99.99,
})
```

### Security Events

```go
logger.LogSecurityEvent("suspicious_login", "Multiple failed login attempts", "high", map[string]interface{}{
    "ip": "192.168.1.1",
    "attempts": 5,
    "user_email": "user@example.com",
})
```

### Performance Monitoring

```go
import "time"

// Measure operation performance
start := time.Now()
// ... your operation ...
duration := time.Since(start)

logger.LogPerformance("user_creation", duration, map[string]interface{}{
    "user_id": "123",
    "complexity": "high",
})
```

### Metrics Logging

```go
logger.LogMetric("active_users", 1250, "count", map[string]interface{}{
    "timestamp": time.Now().Unix(),
})

logger.LogMetric("response_time", 125.5, "ms", map[string]interface{}{
    "endpoint": "/api/users",
})
```

## üé® Output Formats

### Pretty Format (Development)
```
[15:04:05.123] ‚ÑπÔ∏è  INFO [HANDLER] <auth> {login} User login successful | user=u***r@example.com ip=192.168.1.1 took=245ms
```

### Text Format (Simple)
```
[15:04:05] INFO: [handler] {login} User login successful (user=u***r@example.com 245ms)
```

### JSON Format (Production)
```json
{
  "timestamp": "2024-01-15 15:04:05.123",
  "level": "INFO",
  "message": "User login successful",
  "context": {
    "user_id": "123",
    "email": "u***r@example.com",
    "ip": "192.168.1.1",
    "duration_ms": 245
  },
  "layer": "handler",
  "operation": "login",
  "component": "auth",
  "environment": "production"
}
```

## üèó Component Loggers

Create specialized loggers for different application layers:

```go
// Handler layer
handlerLog := logger.NewHandlerLogger()
handlerLog.Info("Request received")

// Service layer
serviceLog := logger.NewServiceLogger()
serviceLog.Debug("Processing business logic")

// Repository layer
repoLog := logger.NewRepositoryLogger()
repoLog.Error("Database query failed")

// Middleware
middlewareLog := logger.NewMiddlewareLogger()
middlewareLog.Warning("Rate limit exceeded")

// Authentication
authLog := logger.NewAuthLogger()
authLog.Info("Token validated")

// Validation
validationLog := logger.NewValidationLogger()
validationLog.Error("Validation failed")

// Cache
cacheLog := logger.NewCacheLogger()
cacheLog.Debug("Cache hit")

// External services
externalLog := logger.NewExternalLogger()
externalLog.Warning("External service slow response")

// Security
securityLog := logger.NewSecurityLogger()
securityLog.Error("Security violation detected")

// Database
dbLog := logger.NewDatabaseLogger()
dbLog.Info("Connection established")

// Custom component
customLog := logger.NewComponentLogger("payment")
customLog.Info("Payment processed")

// Custom layer
layerLog := logger.NewLayerLogger("integration")
layerLog.Error("Integration failed")
```

## üìã Best Practices

### 1. Use Appropriate Log Levels

```go
// ‚úÖ Good
logger.Debug("Detailed debugging info") // Development only
logger.Info("Normal business events")   // Important events
logger.Warning("Recoverable issues")    // Needs attention
logger.Error("Error conditions")        // Needs immediate attention
logger.Fatal("Critical failures")       // Application cannot continue

// ‚ùå Avoid
logger.Info("Starting loop iteration 1847") // Too verbose
logger.Error("User not found")             // Not really an error
```

### 2. Include Relevant Context

```go
// ‚úÖ Good - Rich context
logger.Error("Payment failed", map[string]interface{}{
    "user_id": "123",
    "payment_id": "pay_456",
    "amount": 99.99,
    "error": err.Error(),
    "gateway": "stripe",
})

// ‚ùå Avoid - Missing context
logger.Error("Payment failed")
```

### 3. Use Specialized Loggers

```go
// ‚úÖ Good - Use specialized loggers for specific events
logger.LogAPIRequest("POST", "/api/users", 201, duration, context)
logger.LogAuthAttempt(email, success, reason, context)

// ‚ùå Avoid - Generic logging for specialized events
logger.Info("API request completed")
logger.Info("User logged in")
```

### 4. Leverage Enhanced Methods

```go
// ‚úÖ Good - Use enhanced methods with cause tracking
logger.ErrorWithCause(
    "Database connection failed", 
    "network_timeout", 
    logger.LayerRepository, 
    "connect_db", 
    context,
)

// ‚ùå Avoid - Basic error without context
logger.Error("Database connection failed")
```

### 5. Use Layers and Operations

```go
// ‚úÖ Good - Clear layer and operation
logger.InfoWithOperation(
    "User created successfully",
    logger.LayerService,
    "create_user",
    context,
)

// Set logger layer for consistent logging
serviceLog := logger.NewServiceLogger()
serviceLog.SetOperation("process_payment")
serviceLog.Info("Payment processing started")
```

### 6. Performance Logging

```go
// ‚úÖ Good - Track performance for important operations
func ProcessPayment(paymentID string) error {
    start := time.Now()
    defer func() {
        logger.LogPerformance("process_payment", time.Since(start), map[string]interface{}{
            "payment_id": paymentID,
        })
    }()
    
    // ... payment processing ...
}
```

## üí° Examples

### Complete Web Handler Example

```go
func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    start := time.Now()
    requestID := uuid.New().String()
    
    // Set request context
    context := map[string]interface{}{
        "request_id": requestID,
        "ip": r.RemoteAddr,
        "user_agent": r.UserAgent(),
    }
    
    logger.InfoWithOperation("Create user request started", logger.LayerHandler, "create_user", context)
    
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        logger.ErrorWithCause("Invalid request body", "json_decode_error", logger.LayerHandler, "create_user", context)
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    // Validation
    if err := h.validateUser(&user); err != nil {
        logger.LogValidationError("user", err.Error(), user)
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // Create user
    createdUser, err := h.userService.CreateUser(&user)
    if err != nil {
        logger.LogServiceCall("UserService", "CreateUser", false, err, context)
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    // Success
    context["user_id"] = createdUser.ID
    logger.LogUserActivity(createdUser.ID, createdUser.Email, "create", "user", context)
    
    // Log API request
    duration := time.Since(start)
    logger.LogAPIRequest(r.Method, r.URL.Path, http.StatusCreated, duration, context)
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(createdUser)
}
```

### Service Layer Example

```go
func (s *PaymentService) ProcessPayment(paymentReq *PaymentRequest) (*Payment, error) {
    log := logger.NewServiceLogger()
    log.SetOperation("process_payment")
    
    context := map[string]interface{}{
        "payment_id": paymentReq.ID,
        "user_id": paymentReq.UserID,
        "amount": paymentReq.Amount,
    }
    
    log.Info("Payment processing started", context)
    
    // Validate payment
    if err := s.validatePayment(paymentReq); err != nil {
        log.WarningWithCause("Payment validation failed", "validation_error", logger.LayerService, "validate_payment", context)
        return nil, err
    }
    
    // Process with external gateway
    start := time.Now()
    result, err := s.paymentGateway.Process(paymentReq)
    duration := time.Since(start)
    
    // Log external service call
    logger.LogServiceCall("payment-gateway", "Process", err == nil, err, map[string]interface{}{
        "payment_id": paymentReq.ID,
        "duration_ms": duration.Milliseconds(),
        "gateway": "stripe",
    })
    
    if err != nil {
        log.ErrorWithCause("Payment gateway error", "external_service_error", logger.LayerExternal, "process_payment", context)
        return nil, err
    }
    
    // Save to database
    payment, err := s.paymentRepo.Save(result)
    logger.LogDBOperation("INSERT", "payments", err == nil, err, context)
    
    if err != nil {
        log.ErrorWithCause("Failed to save payment", "database_error", logger.LayerRepository, "save_payment", context)
        return nil, err
    }
    
    // Log performance
    totalDuration := time.Since(start)
    logger.LogPerformance("process_payment", totalDuration, context)
    
    log.Info("Payment processed successfully", context)
    return payment, nil
}
```

## üåç Environment Configuration

### Development Environment
- **Format**: Pretty (with emojis and colors)
- **Level**: Debug (all logs)
- **Debug**: Enabled
- **Features**: File/line info, detailed context

### Staging Environment
- **Format**: JSON (structured)
- **Level**: Debug (for troubleshooting)
- **Debug**: Enabled
- **Features**: Full context, performance tracking

### Production Environment
- **Format**: JSON (for log aggregation)
- **Level**: Info (minimal noise)
- **Debug**: Disabled
- **Features**: Essential context, error tracking, security events

### Environment Variables Reference

```bash
# Core Configuration
APP_ENV=development|staging|production
ENVIRONMENT=development|staging|production  # Alternative to APP_ENV
LOG_FORMAT=json|text|pretty

# Service Information (automatically added to logs)
SERVICE_NAME=restaurant-api  # Default service name
SERVICE_VERSION=1.0.0
```

## üîß Advanced Usage

### Custom Logger Configuration

```go
// Create custom logger with specific settings
customLogger := logger.NewLogger()
customLogger.SetOutputFormat(logger.FormatJSON)
customLogger.SetMinLevel(logger.WarningLevel)
customLogger.AddGlobalField("team", "backend")
customLogger.AddGlobalField("region", "us-west-2")

// Use custom logger
customLogger.Error("Custom configured error", context)
```

### Layer Constants Available

```go
// Available layer constants
logger.LayerHandler    // "handler"
logger.LayerService    // "service" 
logger.LayerRepository // "repository"
logger.LayerMiddleware // "middleware"
logger.LayerAuth       // "auth"
logger.LayerValidation // "validation"
logger.LayerCache      // "cache"
logger.LayerDatabase   // "database"
logger.LayerExternal   // "external"
logger.LayerSecurity   // "security"
```

### Format Constants Available

```go
// Available format constants
logger.FormatJSON   // "json"
logger.FormatText   // "text"
logger.FormatPretty // "pretty"
```

### Level Constants Available

```go
// Available level constants
logger.DebugLevel   // 0
logger.InfoLevel    // 1  
logger.WarningLevel // 2
logger.ErrorLevel   // 3
logger.FatalLevel   // 4
```

## üîí Security Features

### Automatic Email Masking
Emails are automatically masked in logs to protect PII:
- `user@example.com` becomes `u***r@example.com`
- Invalid emails become `***invalid_email***`

### Password Protection
Password fields are automatically hidden:
- Any field named `password`, `token`, or `secret` is masked as `***hidden***`
- Length information is preserved for debugging

### Error Categorization
Errors are automatically categorized for better monitoring:
- `network_error`, `timeout_error`, `auth_error`
- `validation_error`, `permission_error`, `resource_not_found`
- `db_connection_error`, `db_constraint_violation`, etc.

---

This comprehensive logging package provides everything you need for production-ready logging in Go applications, with excellent performance, security, and maintainability features built-in.